http://blog.csdn.net/rankun1/article/details/51026117

项目开发过程中遇到MSVCRTD.LIB和LIBCMTD.LIB的冲突，后来找到原因是代码编译时选择c/c++的运行库版本不一样。于是搞明白了MT,MTd,MD,MDd的区别，问题出现的根源算是明白了。（libc.lib找不到也可以在这里找到答案）
先用简单的方式概括一下原因：
项目-属性-c/c++-代码生成-运行库的选择
选择 MT会用到LIBCMT.LIB   MTD会用到LIBCMTD.LIB
选择 MD会用到MSVCRT.LIB   MDD会用到MSVCRTD.LIB
如果你使用的库用的MT,你自己的程序为MD，则会发生MSVCRTD.LIB和LIBCMTD.LIB的冲突（debug）或者MSVCRT.LIB和LIBCMT.LIB的冲突（release）
解决方法可以保持库编译版本的一致，如果无法保证，就使用终极大招
项目-属性-链接器-命令行-附加参数加入   /FORCE:MULTIPLE
这个参数会自动忽略重复定义

 注意：项目-属性-配置属性-常规-MFC的使用，这一选项，
如果选择了在静态库中使用MFC，则代码生成时只能选择MT（Release）或者MTd（Debug）
如果选择了在共享的DLL中使用MFC则，代码生成时只能选择MD（Release）或者MDd（Debug）

这里总结下他们的区别,后面的那个'd'是代表DEBUG版本，没有'd'的就是RELEASE版本了。
为了防止不同运行库导致的库冲突，需要就行忽略

 版　本		类　型	使用的library	被忽略的library
R  Release	单线程	libc.lib	libcmt.lib, msvcrt.lib, libcd.lib, libcmtd.lib, msvcrtd.lib
多线程	libcmt.lib	libc.lib, msvcrt.lib, libcd.lib, libcmtd.lib, msvcrtd.lib
使用DLL的多线程	msvcrt.lib	libc.lib, libcmt.lib, libcd.lib, libcmtd.lib, msvcrtd.lib
D   Debug	单线程	libcd.lib	libc.lib, libcmt.lib, msvcrt.lib, libcmtd.lib, msvcrtd.lib
多线程	libcmtd.lib	libc.lib, libcmt.lib, msvcrt.lib, libcmtd.lib, msvcrtd.lib
使用DLL的多线程	msvcrtd.lib	libc.lib, libcmt.lib, msvcrt.lib, libcd.lib, libcmtd.lib

遇到libc.lib找不到是因为它是单线程用到的库，而单线程在VS2003以后就被微软取消了，所以老版本的用单线程编译的库就提示libc.lib找不到错误，
你可以在忽略特定库中忽略它，或者去vc6找一个包含进来，



http://blog.monkeypotion.net/gameprog/beginner/love-and-hate-between-msvc-and-crt

多绦芯w慑e (/MTd)： LIBCMTD.lib
多绦芯w (/MT)： LIBCMT.lib
多绦芯w慑e DLL (/MDd)： MSVCRTD.lib
多绦芯w DLL (/MD)： MSVCRT.lib

注意，以上只是渭 C Z言的程式於]有包含 C++ Z言在取Ｈ绻你的程式系y中，有包含 C++ Z言的程式a的，那又是另外一回事了。
但是在０傩缘捻面中，槭颤N找不到相P的O定x呢？因 MSVC 悄悄地统淌皆O者代谔理掉了。
只要在程式a中使用 #include Z法{入任何一 C++ 的祟^n，例如 iostream 或 fstream，MSVC 就在BY器的\作A段中，
自臀BY C++ 的绦须A段程式臁６ C++ 的绦须A段程式欤同涌煞樗版本：

oBBY：

LIBCPMTD.lib（除e版本）
LIBCPMT.lib
BBY：

MSVCPRTD.lib（除e版本）：绦n相依於 MSVCP90D.dll
MSVCPRT.lib：绦n相依於 MSVCP90.dll